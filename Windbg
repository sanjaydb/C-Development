Address in Process
------------------
{
  .In most of the cases , Addresses are  [always virtual addresses]
  .The debugger interprets virtual addresses according to the [page director][ of the current process
  .In kernel mode, the debugger interprets virtual addresses according to the [page directory[ of the process 
   that the [process context specifies]
}


eg
--
{
  cl /nologo p1.cpp /link /release
  fc /b p1.exe p2.exe
  c:\>C:\Program Files (x86)\Vim\vim82\>>xxd -s +0x3c -l 1 p1.exe
  000003c: d8 
  
  loading both exes in windbg
  ---------------------------
  {
    #xxd -r -p mykey.hex > mykey.bin  -> on linux convert hex to binary
    cdb -c ".reload /f ; q" p1.exe 
  
}
 
! heap = To Display Current process heap:
Searching String in a process.
> Imf m notepad
> S -sa Addresss [ OXAAKAx] " hello"

Searching Unicode
S - u 0 L?800000001/2 " Hello"


cl /Zi b.c

e.g-01
------

0:000> !dh p1.exe  -> to list dumpbin like header
 
 hitting main
 -------------
 {
  bp call kernel32!GetCommandLineXXXX settig a bp on that function brings you closer to the main() 
  another function you can set a breakpoint is kernel32!GetEnvironemStringXXXX and then set hardware breaks 
  on the results once you have hit these breakpoints you can you can use the standard prototype of main 
  int main (int argc , char **argv , char* envp) construct to identify your main
  
  to get more nearer you can employ the int argc you execute the binary so you know how many arguments you passed 
  if you passed no arguments to the binary then int argc will be equal to 1 if you passed 8 arguments int argc will be equal to 9
  with that in mind once you reached the breakpoint as enumerated above you can run a loop that enumerates the int argc in stack

    bp $exentry
    bp kernel32!GetCommandLineA
    g
    g
    g poi(@esp)
    .while(@$t0= 0) {
    pc 
    .if ( poi(@esp) == 1) {r $t0 = 1} .else { r $t0 = 0}
    } 
    cdb -c "$$>a< findwmain.txt" hell.exe
 
 
  bp $exentry  -> break main
  bp kernel32!GetCommandLineXXXX
  bp kernel32!GetEnvironemStringXXXX
  :\>cdb -c "bp $exentry;g;bp kernel32!GetCommandlineA;g;g poi(@esp)" p1.exe
  }
 

.reload
.sympath srv*
x b.exe
x b!* 
b!_main  / b!main
x b!*main*

u a96710 -> main 
.open -a a96710 -> source code 
~

bu b!main
bl
g
lm -> To see a list of code modules that are loaded 
k -> To see a stack trace
bu ntdll!ZwWriteFile -> To set and verify a breakpoint at ZwWriteFile
bl
k -> after break  break ->to see the stack trace.
~ -> To see a list of all threads
~0s -> To look at the stack trace for thread 0
k
qd -> to quit

--------------
Contents command on the Help menu
.sympath (Set Symbol Path)
.reload (Reload Module)
x (Examine Symbols)
g (Go)
Break command on the Debug menu
lm (List Loaded Modules)
k (Display Stack Backtrace)
bu (Set Breakpoint)
bl (Breakpoint List)
~ (Thread Status)
~s (Set Current Thread)
.sympath+ (Set Symbol Path) append to existing symbol path
.srcpath (Set Source Path)
Step Into command on the Debug menu (F11)
!analyze -v
qd (Quit and Detach)


